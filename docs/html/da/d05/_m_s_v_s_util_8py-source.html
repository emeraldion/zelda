<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Emeraldion Lodge (codename Zelda): /Users/delphine/Development/SVN/emeraldion.it/zelda/node_modules/gulp-sass/node_modules/node-sass/node_modules/node-gyp/gyp/pylib/gyp/MSVSUtil.py Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css">
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>/Users/delphine/Development/SVN/emeraldion.it/zelda/node_modules/gulp-sass/node_modules/node-sass/node_modules/node-gyp/gyp/pylib/gyp/MSVSUtil.py</h1><a href="../../d6/dca/_m_s_v_s_util_8py.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html">00001</a> <span class="comment"># Copyright (c) 2013 Google Inc. All rights reserved.</span>
<a name="l00002"></a>00002 <span class="comment"># Use of this source code is governed by a BSD-style license that can be</span>
<a name="l00003"></a>00003 <span class="comment"># found in the LICENSE file.</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="stringliteral">"""Utility functions shared amongst the Windows generators."""</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="keyword">import</span> copy
<a name="l00008"></a>00008 <span class="keyword">import</span> os
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment"># A dictionary mapping supported target types to extensions.</span>
<a name="l00012"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#0e422771714be9d956eac58ba8e0ec01">00012</a> TARGET_TYPE_EXT = {
<a name="l00013"></a>00013   <span class="stringliteral">'executable'</span>: <span class="stringliteral">'exe'</span>,
<a name="l00014"></a>00014   <span class="stringliteral">'loadable_module'</span>: <span class="stringliteral">'dll'</span>,
<a name="l00015"></a>00015   <span class="stringliteral">'shared_library'</span>: <span class="stringliteral">'dll'</span>,
<a name="l00016"></a>00016   <span class="stringliteral">'static_library'</span>: <span class="stringliteral">'lib'</span>,
<a name="l00017"></a>00017 }
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#45394a0d4a616941eeec7b9477c56ba1">00020</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#45394a0d4a616941eeec7b9477c56ba1">_GetLargePdbShimCcPath</a>():
<a name="l00021"></a>00021   <span class="stringliteral">"""Returns the path of the large_pdb_shim.cc file."""</span>
<a name="l00022"></a>00022   this_dir = os.path.abspath(os.path.dirname(__file__))
<a name="l00023"></a>00023   src_dir = os.path.abspath(os.path.join(this_dir, <span class="stringliteral">'..'</span>, <span class="stringliteral">'..'</span>))
<a name="l00024"></a>00024   win_data_dir = os.path.join(src_dir, <span class="stringliteral">'data'</span>, <span class="stringliteral">'win'</span>)
<a name="l00025"></a>00025   large_pdb_shim_cc = os.path.join(win_data_dir, <span class="stringliteral">'large-pdb-shim.cc'</span>)
<a name="l00026"></a>00026   <span class="keywordflow">return</span> large_pdb_shim_cc
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#3e09892b8cdd9d799f9f8138ddaa218d">00029</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#3e09892b8cdd9d799f9f8138ddaa218d">_DeepCopySomeKeys</a>(in_dict, keys):
<a name="l00030"></a>00030   <span class="stringliteral">"""Performs a partial deep-copy on |in_dict|, only copying the keys in |keys|.</span>
<a name="l00031"></a>00031 <span class="stringliteral"></span>
<a name="l00032"></a>00032 <span class="stringliteral">  Arguments:</span>
<a name="l00033"></a>00033 <span class="stringliteral">    in_dict: The dictionary to copy.</span>
<a name="l00034"></a>00034 <span class="stringliteral">    keys: The keys to be copied. If a key is in this list and doesn't exist in</span>
<a name="l00035"></a>00035 <span class="stringliteral">        |in_dict| this is not an error.</span>
<a name="l00036"></a>00036 <span class="stringliteral">  Returns:</span>
<a name="l00037"></a>00037 <span class="stringliteral">    The partially deep-copied dictionary.</span>
<a name="l00038"></a>00038 <span class="stringliteral">  """</span>
<a name="l00039"></a>00039   d = {}
<a name="l00040"></a>00040   <span class="keywordflow">for</span> key <span class="keywordflow">in</span> keys:
<a name="l00041"></a>00041     <span class="keywordflow">if</span> key <span class="keywordflow">not</span> <span class="keywordflow">in</span> in_dict:
<a name="l00042"></a>00042       <span class="keywordflow">continue</span>
<a name="l00043"></a>00043     d[key] = copy.deepcopy(in_dict[key])
<a name="l00044"></a>00044   <span class="keywordflow">return</span> d
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#fe219585a25a574674e472cd90fd8eb4">00047</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#fe219585a25a574674e472cd90fd8eb4">_SuffixName</a>(name, suffix):
<a name="l00048"></a>00048   <span class="stringliteral">"""Add a suffix to the end of a target.</span>
<a name="l00049"></a>00049 <span class="stringliteral"></span>
<a name="l00050"></a>00050 <span class="stringliteral">  Arguments:</span>
<a name="l00051"></a>00051 <span class="stringliteral">    name: name of the target (foo#target)</span>
<a name="l00052"></a>00052 <span class="stringliteral">    suffix: the suffix to be added</span>
<a name="l00053"></a>00053 <span class="stringliteral">  Returns:</span>
<a name="l00054"></a>00054 <span class="stringliteral">    Target name with suffix added (foo_suffix#target)</span>
<a name="l00055"></a>00055 <span class="stringliteral">  """</span>
<a name="l00056"></a>00056   parts = name.rsplit(<span class="stringliteral">'#'</span>, 1)
<a name="l00057"></a>00057   parts[0] = <span class="stringliteral">'%s_%s'</span> % (parts[0], suffix)
<a name="l00058"></a>00058   <span class="keywordflow">return</span> <span class="stringliteral">'#'</span>.join(parts)
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#de8b85db4ad2ed19661002b97d06c90f">00061</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#de8b85db4ad2ed19661002b97d06c90f">_ShardName</a>(name, number):
<a name="l00062"></a>00062   <span class="stringliteral">"""Add a shard number to the end of a target.</span>
<a name="l00063"></a>00063 <span class="stringliteral"></span>
<a name="l00064"></a>00064 <span class="stringliteral">  Arguments:</span>
<a name="l00065"></a>00065 <span class="stringliteral">    name: name of the target (foo#target)</span>
<a name="l00066"></a>00066 <span class="stringliteral">    number: shard number</span>
<a name="l00067"></a>00067 <span class="stringliteral">  Returns:</span>
<a name="l00068"></a>00068 <span class="stringliteral">    Target name with shard added (foo_1#target)</span>
<a name="l00069"></a>00069 <span class="stringliteral">  """</span>
<a name="l00070"></a>00070   <span class="keywordflow">return</span> _SuffixName(name, str(number))
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#29b3761609934c91c093035f10ca7964">00073</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#29b3761609934c91c093035f10ca7964">ShardTargets</a>(target_list, target_dicts):
<a name="l00074"></a>00074   <span class="stringliteral">"""Shard some targets apart to work around the linkers limits.</span>
<a name="l00075"></a>00075 <span class="stringliteral"></span>
<a name="l00076"></a>00076 <span class="stringliteral">  Arguments:</span>
<a name="l00077"></a>00077 <span class="stringliteral">    target_list: List of target pairs: 'base/base.gyp:base'.</span>
<a name="l00078"></a>00078 <span class="stringliteral">    target_dicts: Dict of target properties keyed on target pair.</span>
<a name="l00079"></a>00079 <span class="stringliteral">  Returns:</span>
<a name="l00080"></a>00080 <span class="stringliteral">    Tuple of the new sharded versions of the inputs.</span>
<a name="l00081"></a>00081 <span class="stringliteral">  """</span>
<a name="l00082"></a>00082   <span class="comment"># Gather the targets to shard, and how many pieces.</span>
<a name="l00083"></a>00083   targets_to_shard = {}
<a name="l00084"></a>00084   <span class="keywordflow">for</span> t <span class="keywordflow">in</span> target_dicts:
<a name="l00085"></a>00085     shards = int(target_dicts[t].get(<span class="stringliteral">'msvs_shard'</span>, 0))
<a name="l00086"></a>00086     <span class="keywordflow">if</span> shards:
<a name="l00087"></a>00087       targets_to_shard[t] = shards
<a name="l00088"></a>00088   <span class="comment"># Shard target_list.</span>
<a name="l00089"></a>00089   new_target_list = []
<a name="l00090"></a>00090   <span class="keywordflow">for</span> t <span class="keywordflow">in</span> target_list:
<a name="l00091"></a>00091     <span class="keywordflow">if</span> t <span class="keywordflow">in</span> targets_to_shard:
<a name="l00092"></a>00092       <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(targets_to_shard[t]):
<a name="l00093"></a>00093         new_target_list.append(_ShardName(t, i))
<a name="l00094"></a>00094     <span class="keywordflow">else</span>:
<a name="l00095"></a>00095       new_target_list.append(t)
<a name="l00096"></a>00096   <span class="comment"># Shard target_dict.</span>
<a name="l00097"></a>00097   new_target_dicts = {}
<a name="l00098"></a>00098   <span class="keywordflow">for</span> t <span class="keywordflow">in</span> target_dicts:
<a name="l00099"></a>00099     <span class="keywordflow">if</span> t <span class="keywordflow">in</span> targets_to_shard:
<a name="l00100"></a>00100       <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(targets_to_shard[t]):
<a name="l00101"></a>00101         name = _ShardName(t, i)
<a name="l00102"></a>00102         new_target_dicts[name] = copy.copy(target_dicts[t])
<a name="l00103"></a>00103         new_target_dicts[name][<span class="stringliteral">'target_name'</span>] = _ShardName(
<a name="l00104"></a>00104              new_target_dicts[name][<span class="stringliteral">'target_name'</span>], i)
<a name="l00105"></a>00105         sources = new_target_dicts[name].get(<span class="stringliteral">'sources'</span>, [])
<a name="l00106"></a>00106         new_sources = []
<a name="l00107"></a>00107         <span class="keywordflow">for</span> pos <span class="keywordflow">in</span> range(i, len(sources), targets_to_shard[t]):
<a name="l00108"></a>00108           new_sources.append(sources[pos])
<a name="l00109"></a>00109         new_target_dicts[name][<span class="stringliteral">'sources'</span>] = new_sources
<a name="l00110"></a>00110     <span class="keywordflow">else</span>:
<a name="l00111"></a>00111       new_target_dicts[t] = target_dicts[t]
<a name="l00112"></a>00112   <span class="comment"># Shard dependencies.</span>
<a name="l00113"></a>00113   <span class="keywordflow">for</span> t <span class="keywordflow">in</span> new_target_dicts:
<a name="l00114"></a>00114     <span class="keywordflow">for</span> deptype <span class="keywordflow">in</span> (<span class="stringliteral">'dependencies'</span>, <span class="stringliteral">'dependencies_original'</span>):
<a name="l00115"></a>00115       dependencies = copy.copy(new_target_dicts[t].get(deptype, []))
<a name="l00116"></a>00116       new_dependencies = []
<a name="l00117"></a>00117       <span class="keywordflow">for</span> d <span class="keywordflow">in</span> dependencies:
<a name="l00118"></a>00118         <span class="keywordflow">if</span> d <span class="keywordflow">in</span> targets_to_shard:
<a name="l00119"></a>00119           <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(targets_to_shard[d]):
<a name="l00120"></a>00120             new_dependencies.append(_ShardName(d, i))
<a name="l00121"></a>00121         <span class="keywordflow">else</span>:
<a name="l00122"></a>00122           new_dependencies.append(d)
<a name="l00123"></a>00123       new_target_dicts[t][deptype] = new_dependencies
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="keywordflow">return</span> (new_target_list, new_target_dicts)
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#a4d81e08fc96cf3d785d8ddbb4034321">00128</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#a4d81e08fc96cf3d785d8ddbb4034321">_GetPdbPath</a>(target_dict, config_name, vars):
<a name="l00129"></a>00129   <span class="stringliteral">"""Returns the path to the PDB file that will be generated by a given</span>
<a name="l00130"></a>00130 <span class="stringliteral">  configuration.</span>
<a name="l00131"></a>00131 <span class="stringliteral"></span>
<a name="l00132"></a>00132 <span class="stringliteral">  The lookup proceeds as follows:</span>
<a name="l00133"></a>00133 <span class="stringliteral">    - Look for an explicit path in the VCLinkerTool configuration block.</span>
<a name="l00134"></a>00134 <span class="stringliteral">    - Look for an 'msvs_large_pdb_path' variable.</span>
<a name="l00135"></a>00135 <span class="stringliteral">    - Use '&lt;(PRODUCT_DIR)/&lt;(product_name).(exe|dll).pdb' if 'product_name' is</span>
<a name="l00136"></a>00136 <span class="stringliteral">      specified.</span>
<a name="l00137"></a>00137 <span class="stringliteral">    - Use '&lt;(PRODUCT_DIR)/&lt;(target_name).(exe|dll).pdb'.</span>
<a name="l00138"></a>00138 <span class="stringliteral"></span>
<a name="l00139"></a>00139 <span class="stringliteral">  Arguments:</span>
<a name="l00140"></a>00140 <span class="stringliteral">    target_dict: The target dictionary to be searched.</span>
<a name="l00141"></a>00141 <span class="stringliteral">    config_name: The name of the configuration of interest.</span>
<a name="l00142"></a>00142 <span class="stringliteral">    vars: A dictionary of common GYP variables with generator-specific values.</span>
<a name="l00143"></a>00143 <span class="stringliteral">  Returns:</span>
<a name="l00144"></a>00144 <span class="stringliteral">    The path of the corresponding PDB file.</span>
<a name="l00145"></a>00145 <span class="stringliteral">  """</span>
<a name="l00146"></a>00146   config = target_dict[<span class="stringliteral">'configurations'</span>][config_name]
<a name="l00147"></a>00147   msvs = config.setdefault(<span class="stringliteral">'msvs_settings'</span>, {})
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   linker = msvs.get(<span class="stringliteral">'VCLinkerTool'</span>, {})
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   pdb_path = linker.get(<span class="stringliteral">'ProgramDatabaseFile'</span>)
<a name="l00152"></a>00152   <span class="keywordflow">if</span> pdb_path:
<a name="l00153"></a>00153     <span class="keywordflow">return</span> pdb_path
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   variables = target_dict.get(<span class="stringliteral">'variables'</span>, {})
<a name="l00156"></a>00156   pdb_path = variables.get(<span class="stringliteral">'msvs_large_pdb_path'</span>, <span class="keywordtype">None</span>)
<a name="l00157"></a>00157   <span class="keywordflow">if</span> pdb_path:
<a name="l00158"></a>00158     <span class="keywordflow">return</span> pdb_path
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   pdb_base = target_dict.get(<span class="stringliteral">'product_name'</span>, target_dict[<span class="stringliteral">'target_name'</span>])
<a name="l00162"></a>00162   pdb_base = <span class="stringliteral">'%s.%s.pdb'</span> % (pdb_base, TARGET_TYPE_EXT[target_dict[<span class="stringliteral">'type'</span>]])
<a name="l00163"></a>00163   pdb_path = vars[<span class="stringliteral">'PRODUCT_DIR'</span>] + <span class="stringliteral">'/'</span> + pdb_base
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <span class="keywordflow">return</span> pdb_path
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#7ffa4c92068604a8e746d09aea46cb30">00168</a> <span class="keyword">def </span><a class="code" href="../../db/d14/namespacegyp_1_1_m_s_v_s_util.html#7ffa4c92068604a8e746d09aea46cb30">InsertLargePdbShims</a>(target_list, target_dicts, vars):
<a name="l00169"></a>00169   <span class="stringliteral">"""Insert a shim target that forces the linker to use 4KB pagesize PDBs.</span>
<a name="l00170"></a>00170 <span class="stringliteral"></span>
<a name="l00171"></a>00171 <span class="stringliteral">  This is a workaround for targets with PDBs greater than 1GB in size, the</span>
<a name="l00172"></a>00172 <span class="stringliteral">  limit for the 1KB pagesize PDBs created by the linker by default.</span>
<a name="l00173"></a>00173 <span class="stringliteral"></span>
<a name="l00174"></a>00174 <span class="stringliteral">  Arguments:</span>
<a name="l00175"></a>00175 <span class="stringliteral">    target_list: List of target pairs: 'base/base.gyp:base'.</span>
<a name="l00176"></a>00176 <span class="stringliteral">    target_dicts: Dict of target properties keyed on target pair.</span>
<a name="l00177"></a>00177 <span class="stringliteral">    vars: A dictionary of common GYP variables with generator-specific values.</span>
<a name="l00178"></a>00178 <span class="stringliteral">  Returns:</span>
<a name="l00179"></a>00179 <span class="stringliteral">    Tuple of the shimmed version of the inputs.</span>
<a name="l00180"></a>00180 <span class="stringliteral">  """</span>
<a name="l00181"></a>00181   <span class="comment"># Determine which targets need shimming.</span>
<a name="l00182"></a>00182   targets_to_shim = []
<a name="l00183"></a>00183   <span class="keywordflow">for</span> t <span class="keywordflow">in</span> target_dicts:
<a name="l00184"></a>00184     target_dict = target_dicts[t]
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="comment"># We only want to shim targets that have msvs_large_pdb enabled.</span>
<a name="l00187"></a>00187     <span class="keywordflow">if</span> <span class="keywordflow">not</span> int(target_dict.get(<span class="stringliteral">'msvs_large_pdb'</span>, 0)):
<a name="l00188"></a>00188       <span class="keywordflow">continue</span>
<a name="l00189"></a>00189     <span class="comment"># This is intended for executable, shared_library and loadable_module</span>
<a name="l00190"></a>00190     <span class="comment"># targets where every configuration is set up to produce a PDB output.</span>
<a name="l00191"></a>00191     <span class="comment"># If any of these conditions is not true then the shim logic will fail</span>
<a name="l00192"></a>00192     <span class="comment"># below.</span>
<a name="l00193"></a>00193     targets_to_shim.append(t)
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   large_pdb_shim_cc = _GetLargePdbShimCcPath()
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="keywordflow">for</span> t <span class="keywordflow">in</span> targets_to_shim:
<a name="l00198"></a>00198     target_dict = target_dicts[t]
<a name="l00199"></a>00199     target_name = target_dict.get(<span class="stringliteral">'target_name'</span>)
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     base_dict = _DeepCopySomeKeys(target_dict,
<a name="l00202"></a>00202           [<span class="stringliteral">'configurations'</span>, <span class="stringliteral">'default_configuration'</span>, <span class="stringliteral">'toolset'</span>])
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="comment"># This is the dict for copying the source file (part of the GYP tree)</span>
<a name="l00205"></a>00205     <span class="comment"># to the intermediate directory of the project. This is necessary because</span>
<a name="l00206"></a>00206     <span class="comment"># we can't always build a relative path to the shim source file (on Windows</span>
<a name="l00207"></a>00207     <span class="comment"># GYP and the project may be on different drives), and Ninja hates absolute</span>
<a name="l00208"></a>00208     <span class="comment"># paths (it ends up generating the .obj and .obj.d alongside the source</span>
<a name="l00209"></a>00209     <span class="comment"># file, polluting GYPs tree).</span>
<a name="l00210"></a>00210     copy_suffix = <span class="stringliteral">'large_pdb_copy'</span>
<a name="l00211"></a>00211     copy_target_name = target_name + <span class="stringliteral">'_'</span> + copy_suffix
<a name="l00212"></a>00212     full_copy_target_name = _SuffixName(t, copy_suffix)
<a name="l00213"></a>00213     shim_cc_basename = os.path.basename(large_pdb_shim_cc)
<a name="l00214"></a>00214     shim_cc_dir = vars[<span class="stringliteral">'SHARED_INTERMEDIATE_DIR'</span>] + <span class="stringliteral">'/'</span> + copy_target_name
<a name="l00215"></a>00215     shim_cc_path = shim_cc_dir + <span class="stringliteral">'/'</span> + shim_cc_basename
<a name="l00216"></a>00216     copy_dict = copy.deepcopy(base_dict)
<a name="l00217"></a>00217     copy_dict[<span class="stringliteral">'target_name'</span>] = copy_target_name
<a name="l00218"></a>00218     copy_dict[<span class="stringliteral">'type'</span>] = <span class="stringliteral">'none'</span>
<a name="l00219"></a>00219     copy_dict[<span class="stringliteral">'sources'</span>] = [ large_pdb_shim_cc ]
<a name="l00220"></a>00220     copy_dict[<span class="stringliteral">'copies'</span>] = [{
<a name="l00221"></a>00221       <span class="stringliteral">'destination'</span>: shim_cc_dir,
<a name="l00222"></a>00222       <span class="stringliteral">'files'</span>: [ large_pdb_shim_cc ]
<a name="l00223"></a>00223     }]
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     <span class="comment"># This is the dict for the PDB generating shim target. It depends on the</span>
<a name="l00226"></a>00226     <span class="comment"># copy target.</span>
<a name="l00227"></a>00227     shim_suffix = <span class="stringliteral">'large_pdb_shim'</span>
<a name="l00228"></a>00228     shim_target_name = target_name + <span class="stringliteral">'_'</span> + shim_suffix
<a name="l00229"></a>00229     full_shim_target_name = _SuffixName(t, shim_suffix)
<a name="l00230"></a>00230     shim_dict = copy.deepcopy(base_dict)
<a name="l00231"></a>00231     shim_dict[<span class="stringliteral">'target_name'</span>] = shim_target_name
<a name="l00232"></a>00232     shim_dict[<span class="stringliteral">'type'</span>] = <span class="stringliteral">'static_library'</span>
<a name="l00233"></a>00233     shim_dict[<span class="stringliteral">'sources'</span>] = [ shim_cc_path ]
<a name="l00234"></a>00234     shim_dict[<span class="stringliteral">'dependencies'</span>] = [ full_copy_target_name ]
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="comment"># Set up the shim to output its PDB to the same location as the final linker</span>
<a name="l00237"></a>00237     <span class="comment"># target.</span>
<a name="l00238"></a>00238     <span class="keywordflow">for</span> config_name, config <span class="keywordflow">in</span> shim_dict.get(<span class="stringliteral">'configurations'</span>).iteritems():
<a name="l00239"></a>00239       pdb_path = _GetPdbPath(target_dict, config_name, vars)
<a name="l00240"></a>00240 
<a name="l00241"></a>00241       <span class="comment"># A few keys that we don't want to propagate.</span>
<a name="l00242"></a>00242       <span class="keywordflow">for</span> key <span class="keywordflow">in</span> [<span class="stringliteral">'msvs_precompiled_header'</span>, <span class="stringliteral">'msvs_precompiled_source'</span>, <span class="stringliteral">'test'</span>]:
<a name="l00243"></a>00243         config.pop(key, <span class="keywordtype">None</span>)
<a name="l00244"></a>00244 
<a name="l00245"></a>00245       msvs = config.setdefault(<span class="stringliteral">'msvs_settings'</span>, {})
<a name="l00246"></a>00246 
<a name="l00247"></a>00247       <span class="comment"># Update the compiler directives in the shim target.</span>
<a name="l00248"></a>00248       compiler = msvs.setdefault(<span class="stringliteral">'VCCLCompilerTool'</span>, {})
<a name="l00249"></a>00249       compiler[<span class="stringliteral">'DebugInformationFormat'</span>] = <span class="stringliteral">'3'</span>
<a name="l00250"></a>00250       compiler[<span class="stringliteral">'ProgramDataBaseFileName'</span>] = pdb_path
<a name="l00251"></a>00251 
<a name="l00252"></a>00252       <span class="comment"># Set the explicit PDB path in the appropriate configuration of the</span>
<a name="l00253"></a>00253       <span class="comment"># original target.</span>
<a name="l00254"></a>00254       config = target_dict[<span class="stringliteral">'configurations'</span>][config_name]
<a name="l00255"></a>00255       msvs = config.setdefault(<span class="stringliteral">'msvs_settings'</span>, {})
<a name="l00256"></a>00256       linker = msvs.setdefault(<span class="stringliteral">'VCLinkerTool'</span>, {})
<a name="l00257"></a>00257       linker[<span class="stringliteral">'GenerateDebugInformation'</span>] = <span class="stringliteral">'true'</span>
<a name="l00258"></a>00258       linker[<span class="stringliteral">'ProgramDatabaseFile'</span>] = pdb_path
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     <span class="comment"># Add the new targets. They must go to the beginning of the list so that</span>
<a name="l00261"></a>00261     <span class="comment"># the dependency generation works as expected in ninja.</span>
<a name="l00262"></a>00262     target_list.insert(0, full_copy_target_name)
<a name="l00263"></a>00263     target_list.insert(0, full_shim_target_name)
<a name="l00264"></a>00264     target_dicts[full_copy_target_name] = copy_dict
<a name="l00265"></a>00265     target_dicts[full_shim_target_name] = shim_dict
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     <span class="comment"># Update the original target to depend on the shim target.</span>
<a name="l00268"></a>00268     target_dict.setdefault(<span class="stringliteral">'dependencies'</span>, []).append(full_shim_target_name)
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   <span class="keywordflow">return</span> (target_list, target_dicts)
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Oct 7 19:26:27 2015 for Emeraldion Lodge (codename Zelda) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
